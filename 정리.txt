순차탐색

순차 탐색 알고리즘의 시간 복잡도 : 최악의 경우
T(n) = n

순차 탐색 알고리즘의 시간 복잡도 : 평균적인 경우

탐색 대상이 존재하지 않는 경우의 연산횟수 : n
탐색 대상이 존재하는 경우의 연산횟수 : n/2

n * (1/2) + n/2 * (1/2) = 3n/4

T(n) = 3n/4


이진탐색

이진 탐색 알고리즘 -> 배열에 저장된 데이터들이 정렬되어 있을 때 사용 가능!
반으로 나누어서 first, last를 이용해 탐색

이진 탐색 알고리즘의 시간 복잡도 계산 : 최악의 경우를 기준
-n이 1이 되기까지 나눈 횟수 k회, 비교연산 k회 진행
-데이터가 1개 남았을 때, 마지막으로 비교연산 1회 진행

T(n) = k+1

k를 구하기 위해 n* (1/2)^k = 1
1/2을 k회 곱하고 그것을 n에다가 곱하면 데이터가 1개남는 1이 나옴!

식을 바꾸면 n = 2^k --> 로그 2의 n은 k      log(2)n = k



빅-오
O(1) - 상수형 빅-오 
연산횟수가 고정인 유형의 알고리즘을 대표

O(logn) - 로그형 빅-오 
매우 바람직한 유형

O(n) - 선형 빅-오
데이터의 수와 연산횟수가 비례하는 알고리즘

O(nlogn) - 선형로그형 빅-오

O(n^2)
적용하기 부적절

O(n^3)
이 또한 그냥 적용하기 부적절

O(2^n)
지수형 빅-오
사용하기 매우 부적절함


챕터 3
리스트의 이해
리스트는 순차리스트와 연결 리스트로 구분이 됨
순차리스트의 경우 배열을 기반으로 구현된 리스트이며
연결리스트의 경우 메모리의 동적할당을 기반으로 구현된 리스트

연결리스트

원형 연결 리스트